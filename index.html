<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Functional Programming</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/solarized.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/xcode.css">

  <!-- Printing and PDF exports -->
  <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h1>Functional<br>Programming</h1>
      <h4>Introduction</h4>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Agenda

        * Haskell syntax
        * Functional recursion
        * Structural recursion
        * List processing
        * Higher-order functions

        Editor:
        https://repl.it/languages/haskell

        These slides:
        https://dryewo.github.io/functional-programming
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Introduction to Clojure syntax
      </script>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Expressions

          * What is an expression?

          <p class="fragment">Something that can be evaluated and yield a result.</p>
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Expressions

          ```haskell
          1 + 2 + 3       -- => 6
          putStrLn "Hello" -- => IO ()
          10 >= 5         -- => true
          if 10 >= 5 then "Yes" else "No") -- => "Yes"
          ```
          ```haskell
          simpleHTTP (getRequest "http://hackage.haskell.org/")
          ```
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Not everything is an expression

          ```java
          class Bird implements Flying {
            public void takeOff() {
              System.out.println("I fly!");
            }
          }
          ```

          ```java
          if (a == 1)
            b = 2;
          else
            b = 3;
          ```

          ```
          try {
            int a = 1 / 0;
          } catch (Exception e) {
            log.info("This is fine");
          }
          ```
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Side effects

          Some expressions have side effects:

          ```haskell
          -- Create a definition that can be used later
          pi = 3.14159265358
          -- The world is not the same, now it knows `pi`

          -- Use the definition
          pi * 2 * 100
          ```
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Source code files

          When the source code file is loaded, expressions from it are evaluated top to bottom, one by one.

          ```haskell
          sayHello who = putStrLn ("Hello " ++ who ++ "!")
          main = sayHello "World"
          ```
        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ## Data types

          * Primitives
          * Aggregates

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Primitives

          <table>
            <thead>
            <tr>
              <th>Type</th>
              <th>Example</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td>Numbers</td>
              <td>`42`, `2.718`</td>
            </tr>
            <tr>
              <td>Strings</td>
              <td>`"Hello"`</td>
            </tr>
            <tr>
              <td>Booleans</td>
              <td>`true`, `false`</td>
            </tr>
            <tr>
              <td>Keywords</td>
              <td>`:hello`</td>
            </tr>
            </tbody>
          </table>

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Aggregates

          <table>
            <thead>
            <tr>
              <th>Type</th>
              <th>Example</th>
              <th>Comment</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td>Tuples</td>
              <td>`(1 2 3)`</td>
              <td>O(N) access by element number</td>
            </tr>
            <tr>
              <td>List</td>
              <td>`[1 2 3]`</td>
              <td>O(1) access by element number</td>
            </tr>
            </tbody>
          </table>

        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Functions

          * What is a function?

          <p class="fragment">A relation between intput and output.</p>
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Function call

          ```haskell
          checkUserAccess db "kwilcke" "/employees" "application.write"
          ```

          Function name:

          <pre><code data-trim data-noescape>
          <mark>checkUserAccess</mark> db "kwilcke" "/employees" "application.write"
          </code></pre>

          Function args:

          <pre><code data-trim data-noescape>
          checkUserAccess <mark>db</mark> <mark>"kwilcke"</mark> <mark>"/employees"</mark> <mark>"application.write"</mark>
          </code></pre>
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Function definition

          Function with name 'doubleSum' and arguments 'a' and 'b':

          ```haskell
          doubleSum a b = (a + b) * 2
          ```
        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ## Functional programming

          * Immutable data (no variables, only constants!)
          * First-class functions

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          Yes, there are no variables, only constants.

          How do we implement iteration like this?

          ```java
          int res = 0;
          while (n > 0) {
            res = res * n;
            n = n - 1;
          }
          System.out.println(res);
          ```
        </script>
      </section>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Recursion
      </script>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Recursion

          * What is recursion?

          <p class="fragment">A self-referential definition</p>

          <blockquote class="fragment">To understand what recursion is,<br>you must first understand recursion.
          </blockquote>

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Factorial

          * `n! = n * (n-1) * (n-2) * ... * 1`
          * `n! = n * (n-1)!`

          ```haskell
            factorial n =
                if n <= 1 then 1
                else n * factorial (n - 1)
          ```

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Recursion principles

          * Check if it's time to stop
          * If not, call yourself again with modified parameters

          ```haskell
            factorial n =
                if n <= 1 then 1
                else n * factorial (n - 1)
          ```

        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Tail recursion

          Try this out:

          ```haskell
          factorial 1000000000000
          ```

          What's the answer?
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Stack

          * When a function is called, internally its parameters are put into memory
          * That memory is called **Stack**

          <img data-src="images/Stack.png"/>
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Stack overflow

          * Stack is not infinite, it can be filled up:

          <img data-src="images/StackOverflow.png"/>

          * How to avoid this?
        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Tail Recursion

          * We can cheat

          <pre><code data-trim data-noescape>
            factorial n =
                if n <= 1 then 1
                else <mark>n</mark> * factorial (n - 1)
          </code></pre>

          We only need those parameters if we do something with the result of the recursive call.
          What if we avoid it, and instead return the result directly?
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * We can build the result gradually in another argument

          <pre><code data-trim data-noescape>
            factorialTail n acc =
              if n <= 1 then acc
              else factorialTail (n - 1) (n * acc)
          </code></pre>

          <img data-src="images/StackTail.png"/>

          * This is Tail Recursion, when the recursive call is the last instruction in the function body.
          * Haskell automatically optimises such kind of recursions
          * https://www.willamette.edu/~fruehr/haskell/evolution.html
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Quiz

          This is Tail Recursion:

          <pre><code data-trim data-noescape>
          factorialA n acc =
            if n <= 1 then acc
            else factorialA (n - 1) (n * acc)
          </code></pre>

          Is this Tail Recursion?

          <pre><code data-trim data-noescape>
          factorialB n acc =
            if n > 1 then factorialB (n - 1) (n * acc)
            else acc
          </code></pre>

        </script>
      </section>
    </section>
    <section data-markdown>
      <script type="text/template">
        ### Another example

        Greatest Common Divisor (aka Euclidean algorithm)

        ```
        GCD(X, Y)
        1. If Y is 0, then the result is X
        2. Otherwise, the result is
        GCD with X'= Y
             and Y'= remainder of division X by Y
        For example, GCD(33, 18) == 3
        ```

        <img data-src="images/GCD.png" style="background: white"/>

        * Exercise: implement this (use '`rem`' for a remainder)
        * Is this algorithm tail-recursive?

      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Structural recursion

        * Can you define something that has itself as a part?
      </script>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Lists

          List is a data structure.

          * List consists of a Head and a Tail
          * Head is just a value, like `42` or `"Hello"`
          * Tail is another List, can be nil

          <img data-src="images/List.png" style="background: white"/>

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          <img data-src="images/List.png" style="background: white"/>

          What does it have to do with recursion?

          <ul class="fragment">
            <li>It contains itself</li>
            <li>It knows where to stop</li>
          </ul>

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Creating lists

          ```haskell
          -- (:) is used to create a list:
          1 : 2 : [3]

          -- Or just
          [1, 2, 3]
          ```

          **'** before the list prevents Clojure from calling `42` as a function, which would make no sense.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Operations on lists

          ```haskell
          -- getting a Head
          head [1, 2, 3] -- => 1

          -- getting a Tail
          tail [1, 2, 3] -- => [2, 3]

          tail [1] -- => ?

          -- Checking if a list is empty
          null [] -- => True
          null [1, 2] -- => False
          ```

        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### List processing

          * Use recursion
          * Use `first` and `next`

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Adding up a list

          * Here is non-tail-recursive version:

          ```haskell
            sumList lst =
              if null lst then 0
              else head(lst) + sumList(tail lst)
          ```

          * Exercise: implement this in a tail-recursive way, similar to `factorial`

          <pre><code>
            factorialTail 1 acc = acc
            factorialTail n acc = factorialTail (n - 1) (n * acc)
          </code></pre>

          <pre><code data-trim data-noescape class="fragment">
            sumListTailrec [] acc = acc
            sumListTailrec (x:xs) acc = sumListTailrec xs (acc + x)
          </code></pre>

        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Multiplying a list

          ```haskell
          multiplyListTailrec [] acc = acc
          multiplyListTailrec (x:xs) acc = multiplyListTailrec xs (acc * x)
          ```

          * Differs from adding in just one symbol:

          <pre><code data-trim data-noescape>
            sumListTailrec [] acc = acc
            sumListTailrec (x:xs) acc = sumListTailrec xs (acc <mark>+</mark> x)
          </code></pre>

        </script>
      </section>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Higher-order functions

        * Functions that take other functions as arguments

        ```haskell
        (+) 1 2  -- => 3
        (+ 1) 10 -- => 11
        odd 5 -- => True
        ```

        <pre><code data-trim data-noescape>
        foldr <mark>(+)</mark> 10 [1, 2, 3, 4]  -- => 20
        map <mark>(+ 1)</mark> [1, 2, 3, 4]     -- => (2 3 4 5)
        filter <mark>odd</mark> [1, 2, 3, 4]    -- => (1 3)
        </code></pre>

      </script>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Reducing a list to one value

          <img data-src="images/Folding.png" style="background: white"/>

          * In some languages it is called "folding"

        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          * Reducing is done with `reduce` function.

          ```haskell
          -- Args: operation, initial accumulator value, a list
          foldr (+) 0 [1, 2, 3, 4]
          foldr (*) 1 [1, 2, 3, 4]
          ```
        </script>
      </section>
    </section>
    <section>
      <section data-markdown>
        <script type="text/template">
          ### Mapping a function over a list

          <img data-src="images/Mapping.png" style="background: white"/>

          * Creates a list of the same size, containing results of applying the function to each element.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Mapping is done with `map` function

          ```haskell
          -- `+1` adds 1 to the argument
          map (+ 1) [1, 2, 3, 4] -- => [2, 3, 4, 5]
          -- The result is the same as
          [(+1) 1, (+ 1) 2, (+ 1) 3, (+ 1) 4]
          ```
        </script>
      </section>

    </section>
    <section data-markdown>
      <script type="text/template">
        * Exercise:

        ```
        Given a list like:
        ((1 2 3) (4 5 6) (7 8 9))
        calculate a list containing sums of sublists:
        (6 15 24)
        ```

        * Use `map` and `reduce`

      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        * Exercise:

        Write a function that reverses a list.

        * Use tail-recursive approach with an accumulator.
        * Is it more like `map` or `reduce`?

      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Wrap-up

        * Functional programming has no variables (data is immutable).
        * You have to use recursion.
        * Tail recursion is important to avoid blowing the stack.
        * Lists are defined recursively, as head and a list.
        * Functions are first-class citizens, they can be given to other functions as arguments.
        * IRL, everyone uses `map`, `reduce`, `filter` and other high-order functions to process lists.

      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Reading list

        * Structure and Interpretation of Computer Programs (SICP), H. Abelson, G. J. Sussman, J. Sussman
        * Functional programming in Scala, R. Bjarnason, P. Chiusano

      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        # The End

      </script>
    </section>
  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
</script>
</body>
</html>
